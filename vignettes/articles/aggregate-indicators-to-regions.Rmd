---
title: "Aggregate indicators to regions"
output: 
  bookdown::html_document2:
    toc: yes
    toc_depth: 2
    number_sections: FALSE
pkgdown:
  as_is: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(eaTools)
library(tmap)
library(stars)
library(dplyr)
library(stats)
library(ggplot2)
```

# Introduction

We are often in a position where we need to aggregate indicators to certain regions within a larger accounting area. This process is a little different depending on the spatial coverage of the indicator and whether the regions are defined in a raster or with polygons.

We will use some example data sets included in the package.

```{r}
data("ex_polygons")
data("accounting_area")
data("ex_raster")
```

```{r example-data, fig.cap="Showing the three example datasets on top of eachother. The raster layer (ex_raster) have cell values 1, 2 or 3, as shown in the legend. The five large polygons is the accounting_area layer, and the smaller polygins, visible as specks, is teh ex_polygons layer."}
tm_shape(ex_raster)+
  tm_raster(alpha = 1,
            style = "cat")+
  tm_shape(accounting_area)+
  tm_polygons(alpha = .6)+
  tm_shape(ex_polygons)+
  tm_polygons(border.col = "black")+
  tm_layout(legend.outside = T)+
  tm_scale_bar(position = c("right", "bottom"), width = 0.3)

```

## Case 1: Aggregate indicator values from small polygons for each of the three classes in the raster layer, and *spread them* to cover the entire raster layer.

In this example we are imagining that `ex_polygons`, and the column `condition_variable_2`, contains a condition variable, and that `ex_raster` denotes homogeneous areas. We aknowledge a spatial bias in the sampling of the dummy condition variable. However, in this hypothetical example, we think that the variable/indicator can be said to be representative of the homogeneous area class that it belongs to. We therefore allow ourselves to extrapolate, or *spread*, the mean indicator values within a given homogeneous area class to the other grid cells of the same class.

To be able to see what we are doing, we will zoom in on the data above.

```{r}
ex_raster_zoom <- ex_raster[,5:6, 28:29]
ex_polygons_zoom <- sf::st_crop(ex_polygons, ex_raster_zoom)
```

First we would scale the variable, and make it into an indicator using `ea_normalise()` (See `vignette("Normalise condition variable")`).
```{r}
ex_polygons_zoom$indicator <- ea_normalise(ex_polygons_zoom,
                                           "condition_variable_2",
                                           upper_reference_level = 7)
```

```{r example-indicator-hist, fig.cap="Histogram of the example indicator values."}
ggplot(ex_polygons_zoom, aes(x = indicator))+
  geom_histogram(fill = "grey",
                 colour = "black",
                 size = 1.2)+
  theme_bw(base_size = 12)
```


```{r exampla-data-zoom, fig.cap="Example data produced by zoomin in on four grid cells in the above figure."}
tm_shape(ex_raster_zoom)+
  tm_raster(style="cat")+
  tm_shape(ex_polygons_zoom)+
  tm_polygons(col = "indicator",
              palette = "RdYlGn",
              border.col = "black")+
  tm_layout(legend.outside = T)+
  tm_scale_bar(position = c("left", "bottom"), width = 0.3)
```



Although it is a rather heavy operation, we will now vectorize the raster. The number of grid cells should not be excessive, or this will be too slow.

```{r}
ex_raster_zoom_vect <- st_as_sf(ex_raster_zoom, as_points = FALSE, merge = TRUE)
```

Now well get the intersections. Think of this as pulling values from the vectorized raster (categorical class 1 -3) over to to the small polygons.
```{r, warning=F}
ex_polygons_raster_zoom <- st_intersection(ex_polygons_zoom, ex_raster_zoom_vect)
```
The above operation splits the small polygons in `ex_polygons_zoom` when they span two or more raster grid cells. 

I will manipulate the data set slightly, just to make some contrasts between the three homogeneous area classes more visible. 
```{r}
ex_polygons_raster_zoom$indicator[ex_polygons_raster_zoom$values ==1][1:5] <- 1
```

We can now calculate the area weighted mean for each homogeneous area class. First we need to calculate the area of each polygon
```{r}
ex_polygons_raster_zoom$area <- units::drop_units(st_area(ex_polygons_raster_zoom))
```




```{r}
(myWeightedMeans <- ex_polygons_raster_zoom %>%
  group_by(homogeneous_area_class = values) %>%
  summarise(meanIndicatorValue = 
              weighted.mean(x = indicator,
                            w = area)))
```

Homogeneous area class 3 is in better condition, apparently. 
Let's now pull these averages back to the vectorized grid.

```{r}
ex_raster_zoom_vect$meanIndicator <- myWeightedMeans$meanIndicatorValue[match(ex_raster_zoom_vect$values, myWeightedMeans$homogeneous_area_class)]
```

```{r indicator-values-on-raster, fig.cap="Example where the area weighted averages of the indicator values in the small polygons are spread over the raster cells with each homogeneous area class."}
tm_shape(ex_raster_zoom_vect)+
  tm_polygons(col = "meanIndicator",
              palette = "RdYlGn",
              breaks = seq(0,1,0.2))+
  tm_shape(ex_polygons_zoom)+
  tm_polygons(col = "indicator",
              palette = "RdYlGn",
              breaks = seq(0,1,0.2),
              border.col = "black")+
  tm_layout(legend.outside = T)
```

In the map above, the colour of the cells are in a way the average colour of the polygons that overlay these cells. Note that the bottom left cell now still has an indicator value even though it didn't have any data to start with.

The next thing we should consider is this: do we have enough data to actually estimate an indicator value for a given region. Take the top left grid cell for example. The condition is apparently quite good, but this value is based on a variable recorded in only about two smaller polygons, and we have extrapolated these data to the entire grid cell. We could impose a rule that we need _x_ number of data points (or x% areal coverage) before we allow a mean indicator value to represent an entire homogeneous area class.

I'm going to assume for this example that we use expoert judgement to say that we need 5 data points to base an average on. If we have less than that we will not attempt to estimate an average.

```{r}
(myConditionalWeightedMeans <- 
   ex_polygons_raster_zoom %>%
  group_by(homogeneous_area_class = values) %>%
  mutate(numberOfDatapoints = n(),
         indicator_NA = ifelse(numberOfDatapoints >=5, indicator, NA)) %>%
  summarise(meanIndicator = weighted.mean(indicator_NA, area))
)
```

```{r}
ex_raster_zoom_vect$meanIndicator_conditional <- myConditionalWeightedMeans$meanIndicator[match(ex_raster_zoom_vect$values, myConditionalWeightedMeans$homogeneous_area_class)]
```

```{r indicators-on-raster-na, fig.cap="Example where the area weighted averages of the indicator values in the small polygons are spread over the raster cells with each homogeneous area class. Only homogeneous area class with more than 5 data points get indicator values."}
tm_shape(ex_raster_zoom_vect)+
  tm_polygons(col = "meanIndicator_conditional",
              palette = "RdYlGn",
              breaks = seq(0,1,0.2))+
  tm_shape(ex_polygons_zoom)+
  tm_polygons(col = "indicator",
              palette = "RdYlGn",
              breaks = seq(0,1,0.2),
              border.col = "black")+
  tm_layout(legend.outside = T)
```

We can then rasterise this back again, because a raster format is more useful for subsequent analyses, such as aggregating indicators.

```{r}
newIndicator <- stars::st_rasterize(ex_raster_zoom_vect, ex_raster_zoom)
```



```{r final-raster, fig.cap="The final raster with indicator values."}
tm_shape(newIndicator[3,,])+
  tm_raster(palette = "RdYlGn",
              breaks = seq(0,1,0.2))+
  tm_layout(legend.outside = T)
```

And there we have it.
