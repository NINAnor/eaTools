[{"path":"https://ninanor.github.io/eaTools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 eaTools authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ninanor.github.io/eaTools/articles/aggregate-indicators-to-regions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Aggregate indicators to regions","text":"often position need aggregate indicators certain regions within larger accounting area. process little different depending spatial coverage indicator whether regions defined raster polygons. use example data sets included package. Figure 1: Showing three example datasets top eachother. raster layer (ex_raster) cell values 1, 2 3, shown legend. five large polygons accounting_area layer, smaller polygins, visible specks, teh ex_polygons layer.","code":"data(\"ex_polygons\") data(\"accounting_area\") data(\"ex_raster\") tm_shape(ex_raster)+   tm_raster(alpha = 1,             style = \"cat\")+   tm_shape(accounting_area)+   tm_polygons(alpha = .6)+   tm_shape(ex_polygons)+   tm_polygons(border.col = \"black\")+   tm_layout(legend.outside = T)+   tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)"},{"path":"https://ninanor.github.io/eaTools/articles/aggregate-indicators-to-regions.html","id":"case-1-aggregate-indicator-values-from-small-polygons-for-each-of-the-three-classes-in-the-raster-layer-and-spread-them-to-cover-the-entire-raster-layer-","dir":"Articles","previous_headings":"","what":"Case 1: Aggregate indicator values from small polygons for each of the three classes in the raster layer, and spread them to cover the entire raster layer.","title":"Aggregate indicators to regions","text":"example imagining ex_polygons, column condition_variable_2, contains condition variable, ex_raster denotes homogeneous areas. aknowledge spatial bias sampling dummy condition variable. However, hypothetical example, think variable/indicator can said representative homogeneous area class belongs . therefore allow extrapolate, spread, mean indicator values within given homogeneous area class grid cells class. able see , zoom data . First scale variable, make indicator using ea_normalise() (See vignette(\"Normalise condition variable\")). Figure 2: Histogram example indicator values. Figure 3: Example data produced zoomin four grid cells figure. manipulate data set slightly, just make contrasts three homogeneous area classes visible. now want calculate area weighted mean homogeneous area class, .e. three different coloured grid cells Fig. 3. First process ex_raster_zoom define homogeneous areas based cell values. aggregate indicator values ex_polygons_zoom homogeneous area class, spread mean indicator values across grid cells. Even grid cells originally indicator values associated populated area weighted mean homogeneous area class. Lets step without defining threshold many data points need calculating average. Figure 4: Example area weighted averages indicator values small polygons spread raster cells homogeneous area class. left example, homogeneous area class 5 data points get indicator values. map , color cells way average color polygons overlay cells. Note bottom left cell now still indicator value even though didn’t data start . look right hand figure, homogeneous area class 3 better condition, indicator value based data points. assign threshold number available data points, function returns NA. can rasterise back , raster format useful subsequent analyses, aggregating indicators. can use existing function sf package.","code":"ex_raster_zoom <- ex_raster[,5:6, 28:29] ex_polygons_zoom <- sf::st_crop(ex_polygons, ex_raster_zoom) ex_polygons_zoom$indicator <- ea_normalise(ex_polygons_zoom,                                            \"condition_variable_2\",                                            upper_reference_level = 7) ggplot(ex_polygons_zoom, aes(x = indicator))+   geom_histogram(fill = \"grey\",                  colour = \"black\",                  size = 1.2)+   theme_bw(base_size = 12) tm_shape(ex_raster_zoom)+   tm_raster(style=\"cat\")+   tm_shape(ex_polygons_zoom)+   tm_polygons(col = \"indicator\",               palette = \"RdYlGn\",               border.col = \"black\")+   tm_layout(legend.outside = T)+   tm_scale_bar(position = c(\"left\", \"bottom\"), width = 0.3) ex_polygons_zoom$indicator[2:6] <- 1 myRegions <- ea_homogeneous_area(ex_raster_zoom) myIndicator <- ea_spread(indicator_data = ex_polygons_zoom,                          indicator = indicator,                          regions = myRegions,                          groups = values,                          threshold = 5) myIndicator_noThreshold <- ea_spread(indicator_data = ex_polygons_zoom,                          indicator = indicator,                          regions = myRegions,                          groups = values) tmap_arrange(   tm_shape(myIndicator)+     tm_polygons(col = \"meanIndicatorValue\",                 title=\"Indicator value\",                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2))+     tm_shape(ex_polygons_zoom)+     tm_polygons(col = \"indicator\",                 legend.show = F,                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2),                 border.col = \"black\")+     tm_layout(legend.position = c('left', 'top'),               title = \"Threshold = 5 data points\")   ,   tm_shape(myIndicator_noThreshold)+     tm_polygons(col = \"meanIndicatorValue\",                 title=\"Indicator value\",                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2))+     tm_shape(ex_polygons_zoom)+     tm_polygons(col = \"indicator\",                 legend.show = F,                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2),                 border.col = \"black\")+     tm_layout(legend.position = c('left', 'top'),               title = \"No threshold\") ) newIndicator_raster <- stars::st_rasterize(myIndicator, ex_raster_zoom)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Normalise condition variable","text":"article explains use ea_normalise(). Use function normalise (also called rescale) condition variables based defined reference levels (also called reference values). Let’s get example data. sf object 2079 rows (.e. polygons). column condition_variable_2 contains dummy variable take raw units (e.g. kg km).  want normalise variable become bound 0 1.","code":"data(\"ex_polygons\") class(ex_polygons) #> [1] \"sf\"         \"data.frame\" plot(ex_polygons$condition_variable_2)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"plotting-the-results","dir":"Articles","previous_headings":"","what":"Plotting the results","title":"Normalise condition variable","text":"helpful visualise transformation make sure function expect (Fig. 1). Figure 1: Visualising results normalising linear scaling condition_variable_2 using defined upper reference level default lower reference level zero way default method linear scaling upper lower reference levels, indicator values truncated 1 0. can also add break point (Fig. 2). break point value condition variable become scaled 0.6 (threshold used define good ecological condition contexts). Figure 2: Visualising results normalising linear break-point scaling condition_variable_2 using defined upper reference level default lower reference level zero can two-sided normalisation defining optimum value (Fig. 3). Note non-compatible defining break-point. Figure 3: Visualising results two-sided normalising condition_variable_2 using defined upper reference level default lower reference level zero Finally also option scaling condition variable using sigmoid function (Fig. 4), positive (Fig. 6) negative (Fig. 5) exponential function. latter two non-compatible defined break-point, first one . Figure 4: Visualising results normalising sigmoid transformation condition_variable_2 using defined upper reference level default lower reference level zero Figure 5: Visualising results normalising negative exponensial transformation condition_variable_2 using defined upper reference level default lower reference level zero Figure 6: Visualising results normalising positive exponensial transformation condition_variable_2 using defined upper reference level default lower reference level zero","code":"eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              break_point = 5,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              optimum = 5,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"sigmoid\",              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"exponential convex\",              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"exponential concave\",              plot = T)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"export-values","dir":"Articles","previous_headings":"Plotting the results","what":"Export values","title":"Normalise condition variable","text":"’ve found correct settings normalisation, can export new values like ","code":"ex_polygons$condition_indicator_2 <- eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7)"},{"path":"https://ninanor.github.io/eaTools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Anders Kolstad. Author, maintainer.","code":""},{"path":"https://ninanor.github.io/eaTools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kolstad (2023). eaTools: Tools Ecosystem Accounting. R package version 0.0.0.9000, https://ninanor.github.io/eaTools/.","code":"@Manual{,   title = {eaTools: Tools for Ecosystem Accounting},   author = {Anders Kolstad},   year = {2023},   note = {R package version 0.0.0.9000},   url = {https://ninanor.github.io/eaTools/}, }"},{"path":"https://ninanor.github.io/eaTools/index.html","id":"eatools-","dir":"","previous_headings":"","what":"Tools for Ecosystem Accounting","title":"Tools for Ecosystem Accounting","text":"goal eaTools provide tools creating ecosystem accounts.","code":""},{"path":"https://ninanor.github.io/eaTools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Ecosystem Accounting","text":"can install development version eaTools GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"NINAnor/eaTools\")"},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":null,"dir":"Reference","previous_headings":"","what":"accounting_area — accounting_area","title":"accounting_area — accounting_area","text":"accounting_area outline five regions.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"accounting_area — accounting_area","text":"","code":"accounting_area"},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"accounting_area — accounting_area","text":"sf object name Municipality name SHAPE_Area area polygons geometry geometry sf object","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_homogeneous_area — ea_homogeneous_area","title":"ea_homogeneous_area — ea_homogeneous_area","text":"function create new geometry based two input geometries. function meant precede ea_spread define homogeneous area can spread (.e. aggregate) indicator values.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_homogeneous_area — ea_homogeneous_area","text":"","code":"ea_homogeneous_area(delineation1 = NULL, delineation2 = NULL)"},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_homogeneous_area — ea_homogeneous_area","text":"delineation1 geometry (sf stars object) delineation2 second, optional, geometry (sf stars object)","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_homogeneous_area — ea_homogeneous_area","text":"function returns sf object polygons defined intersection delineation1 delineation2. either inputs rasters, vectorised, neighboring cells identical values merged.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_homogeneous_area — ea_homogeneous_area","text":"","code":"data(\"ex_raster\") ea_homogeneous_area(ex_raster)"},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_normalise — ea_normalise","title":"ea_normalise — ea_normalise","text":"function normalise, re-scale, numerical vector condition variable become value 0 1, bound upper reference level.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_normalise — ea_normalise","text":"","code":"ea_normalise(   data = NULL,   vector = NULL,   upper_reference_level = NULL,   lower_reference_level = 0,   scaling_function = \"linear\",   reverse = FALSE,   break_point = NULL,   optimum = NULL,   plot = FALSE )"},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_normalise — ea_normalise","text":"data Data set class sf vector Numerical vector inside data normalised upper_reference_level upper reference level normalise vector. Can single number vector length equal vector. lower_reference_level lower reference level normalise vector. Defaults 0. Can single number vector length equal vector. scaling_function one c(\"linear\", \"sigmoid\", \"exponential convex\", \"exponential concave\") reverse Logical. indicator values reversed (.e. giving high variable value low indicator value) break_point Numerical vector single value indicating value variable scaled 0.6 indicator. optimum Numerical vector single value indicating upper reference value two-sided indicator. plot Logical. Wheter return plot comparing normalised raw values, return normalised values (default).","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_normalise — ea_normalise","text":"plot = TRUE return ggplot comparing normalised raw values. plot = False return numerical vector, normalised version vetcor","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_normalise — ea_normalise","text":"","code":"data(\"ex_polygons\") ea_normalise(data = ex_polygons,             vector = \"condition_variable_2\",             upper_reference_level = 8,             plot=TRUE)"},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_spread — ea_spread","title":"ea_spread — ea_spread","text":"function aggregate (area weigted means) indicator values stored spatial object (sf stars object) homogeneous area class, subsequently spread values populate area homogeneous area classes.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_spread — ea_spread","text":"","code":"ea_spread(indicator_data, indicator, regions, groups, threshold = 1)"},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_spread — ea_spread","text":"indicator_data spatial object (currently inly sf objects supported) containing scaled indicator values indicator Column name indicator_data containing indicator values. unquoted. regions spatial object (currently stars objects supported) cell values assign areas homogeneous area classes. groups Name regions containing homogeneous area classes. unquoted. threshold Number data points (.e. unique indicator values) needed calculate average indicator value. Defaults 1 (.e. threshold).","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_spread — ea_spread","text":"returned object sf object containing homogeneous area classes mean indicator values.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_spread — ea_spread","text":"","code":"data(\"ex_polygons\") data(\"ex_raster\")  # Example using a raster to define homogeneous area classes. # Zooming in on the example data ex_raster_zoom <- ex_raster[,5:6, 28:29] ex_polygons_zoom <- sf::st_crop(ex_polygons, ex_raster_zoom) #> Warning: attribute variables are assumed to be spatially constant throughout all geometries # Scale the indicator ex_polygons_zoom$indicator <- ea_normalise(ex_polygons_zoom, \"condition_variable_2\", upper_reference_level = 7) # Tweak the data slightly for exagerated effect ex_polygons_zoom$indicator[2:6] <- 1 # Process the `ex_raster_zoom` and define homogeneous areas based on the cell values. myRegions <- ea_homogeneous_area(ex_raster_zoom) # Now use the function out <- ea_spread(indicator_data = ex_polygons_zoom, indicator = indicator, regions = myRegions, groups = values) # And plot the results plot(out[,2])"},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":null,"dir":"Reference","previous_headings":"","what":"ex_polygons — ex_polygons","title":"ex_polygons — ex_polygons","text":"Example polygon data eaTools. ex_polygons sf object dummy condition variable (un-scaled). cover entire accounting area.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ex_polygons — ex_polygons","text":"","code":"ex_polygons"},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"ex_polygons — ex_polygons","text":"sf object ID Unique row IDs SHAPE_Area area polygons SHAPE geometry sf object condition_variable_1 positive number zero 10 condition_variable_2 normally distributed vector mean =2 sd = 2 condition_variable_3 number value 0 1","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"ex_raster — ex_raster","title":"ex_raster — ex_raster","text":"ex_raster 1000x1000m raster grid extent account area, cells randomly classed either 1, 2 3.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ex_raster — ex_raster","text":"","code":"ex_raster"},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"ex_raster — ex_raster","text":"stars object 40 rows 34 column(s)","code":""}]
