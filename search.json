[{"path":"https://ninanor.github.io/eaTools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 eaTools authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://ninanor.github.io/eaTools/articles/aggregate-indicators-to-regions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Aggregate indicators to regions","text":"often position need aggregate indicators certain regions within larger accounting area. process little different depending spatial coverage indicator whether regions defined raster polygons. use example data sets included package. Figure 1: Showing three example datasets top eachother. raster layer (ex_raster) cell values 1, 2 3, shown legend. five large polygons accounting_area layer, smaller polygins, visible specks, teh ex_polygons layer.","code":"data(\"ex_polygons\") data(\"accounting_area\") data(\"ex_raster\") tm_shape(ex_raster)+   tm_raster(alpha = 1,             style = \"cat\")+   tm_shape(accounting_area)+   tm_polygons(alpha = .6)+   tm_shape(ex_polygons)+   tm_polygons(border.col = \"black\")+   tm_layout(legend.outside = T)+   tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)"},{"path":"https://ninanor.github.io/eaTools/articles/aggregate-indicators-to-regions.html","id":"case-1-aggregate-indicator-values-from-small-polygons-for-each-of-the-three-classes-in-the-raster-layer-and-spread-them-to-cover-the-entire-raster-layer-","dir":"Articles","previous_headings":"","what":"Case 1: Aggregate indicator values from small polygons for each of the three classes in the raster layer, and spread them to cover the entire raster layer.","title":"Aggregate indicators to regions","text":"example imagining ex_polygons, column condition_variable_2, contains condition variable, ex_raster denotes homogeneous areas. aknowledge spatial bias sampling dummy condition variable. However, hypothetical example, think variable/indicator can said representative homogeneous area class belongs . therefore allow extrapolate, spread, mean indicator values within given homogeneous area class grid cells class. able see , zoom data . First scale variable, make indicator using ea_normalise() (See vignette(\"Normalise condition variable\")). Figure 2: Histogram example indicator values. Figure 3: Example data produced zooming four grid cells figure. manipulate data set slightly, just make contrasts three homogeneous area classes visible. now want calculate area weighted mean homogeneous area class, .e. three different colored grid cells Fig. 3. First process ex_raster_zoom (vectorise ) define homogeneous areas based cell values. aggregate indicator values ex_polygons_zoom homogeneous area class, spread mean indicator values across grid cells. Even grid cells originally indicator values associated populated area weighted mean homogeneous area class. Lets step without defining threshold many data points need calculating average. Figure 4: Example area weighted averages indicator values small polygons spread raster cells homogeneous area class. left example, homogeneous area class 5 data points get indicator values. standard errors extrapolated indicator values shown bottom row, produced bootstrapping indicator data small polygoins. map (top row), color cells way average color polygons overlay cells. Note bottom left cell (still top row) now still indicator value even though didn’t data start . look top right figure, homogeneous area class 3 (top left cell) better condition, indicator value based data points (3 fact, can see th next table). assign threshold number available data points, function returns NA (right column). low number data points homogeneous area class 3 also reflected large standard deviatio estimate (bottom right pane). can also use function return values, including summary statistics, data frame: can chose rasterise back , raster format useful subsequent analyses, aggregating indicators. can use existing function sf package.","code":"ex_raster_zoom <- ex_raster[,5:6, 28:29] ex_polygons_zoom <- sf::st_crop(ex_polygons, ex_raster_zoom) ex_polygons_zoom$indicator <- ea_normalise(ex_polygons_zoom,                                            \"condition_variable_2\",                                            upper_reference_level = 7) ggplot(ex_polygons_zoom, aes(x = indicator))+   geom_histogram(fill = \"grey\",                  colour = \"black\",                  size = 1.2)+   theme_bw(base_size = 12) tm_shape(ex_raster_zoom)+   tm_raster(style=\"cat\")+   tm_shape(ex_polygons_zoom)+   tm_polygons(col = \"indicator\",               palette = \"RdYlGn\",               border.col = \"black\")+   tm_layout(legend.outside = T)+   tm_scale_bar(position = c(\"left\", \"bottom\"), width = 0.3) ex_polygons_zoom$indicator[2:6] <- 1 myRegions <- ea_homogeneous_area(ex_raster_zoom,                                  groups = values) myIndicator <- ea_spread(indicator_data = ex_polygons_zoom,                          indicator = indicator,                          regions = myRegions,                          groups = values,                          threshold = 5) myIndicator_noThreshold <- ea_spread(indicator_data = ex_polygons_zoom,                          indicator = indicator,                          regions = myRegions,                          groups = values) tmap_arrange(      # W/ threshold   tm_shape(myIndicator)+     tm_polygons(col = \"w_mean\",                 title=\"Indicator value\",                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2))+     tm_shape(ex_polygons_zoom)+     tm_polygons(col = \"indicator\",                 legend.show = F,                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2),                 border.col = \"black\")+     tm_layout(legend.position = c('left', 'top'),               title = \"Threshold = 5 data points\"),         # No threshold   tm_shape(myIndicator_noThreshold)+     tm_polygons(col = \"w_mean\",                 title=\"Indicator value\",                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2))+     tm_shape(ex_polygons_zoom)+     tm_polygons(col = \"indicator\",                 legend.show = F,                 palette = \"RdYlGn\",                 breaks = seq(0,1,0.2),                 border.col = \"black\")+     tm_layout(legend.position = c('left', 'top'),               title = \"No threshold\"),      # errors    tm_shape(myIndicator)+     tm_polygons(col = \"sd\",                 title=\"Standard error\",                 palette = \"-RdYlGn\",                 n=4)+     tm_layout(legend.position = c('left', 'top')),   # errors   tm_shape(myIndicator_noThreshold)+     tm_polygons(col = \"sd\",                 title=\"Standard error\",                 palette = \"-RdYlGn\",                 n=4)+     tm_layout(legend.position = c('left', 'top')),   heights = c(.8,.2) ) ea_spread(indicator_data = ex_polygons_zoom,                          indicator = indicator,                          regions = myRegions,                          groups = values,                          summarise = T) #>   values total_area  n     w_mean      mean         sd #> 1      1  69675.832 30 0.24102147 0.3708932 0.06908202 #> 2      2  58330.105  7 0.08642357 0.3810810 0.12668358 #> 3      3   3351.623  3 0.65946526 0.7039941 0.21331775 newIndicator_raster <- stars::st_rasterize(myIndicator, ex_raster_zoom)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Normalise condition variable","text":"article explains use ea_normalise(). Use function normalise (also called rescale) condition variables based defined reference levels (also called reference values). Let’s get example data. sf object 2079 rows (.e. polygons). column condition_variable_2 contains dummy variable take raw units (e.g. kg km).  want normalise variable become bound 0 1.","code":"data(\"ex_polygons\") class(ex_polygons) #> [1] \"sf\"         \"data.frame\" plot(ex_polygons$condition_variable_2)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"plotting-the-results","dir":"Articles","previous_headings":"","what":"Plotting the results","title":"Normalise condition variable","text":"helpful visualise transformation make sure function expect (Fig. 1). Figure 1: Visualising results normalising linear scaling condition_variable_2 using defined upper reference level default lower reference level zero way default method linear scaling upper lower reference levels, indicator values truncated 1 0. can also add break point (Fig. 2). break point value condition variable become scaled 0.6 (threshold used define good ecological condition contexts). Figure 2: Visualising results normalising linear break-point scaling condition_variable_2 using defined upper reference level default lower reference level zero can two-sided normalisation defining optimum value (Fig. 3). Note non-compatible defining break-point. Figure 3: Visualising results two-sided normalising condition_variable_2 using defined upper reference level default lower reference level zero Finally also option scaling condition variable using sigmoid function (Fig. 4), positive (Fig. 6) negative (Fig. 5) exponential function. latter two non-compatible defined break-point, first one . Figure 4: Visualising results normalising sigmoid transformation condition_variable_2 using defined upper reference level default lower reference level zero Figure 5: Visualising results normalising negative exponensial transformation condition_variable_2 using defined upper reference level default lower reference level zero Figure 6: Visualising results normalising positive exponensial transformation condition_variable_2 using defined upper reference level default lower reference level zero","code":"eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              break_point = 5,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              optimum = 5,              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"sigmoid\",              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"exponential convex\",              plot = T) eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7,              scaling_function = \"exponential concave\",              plot = T)"},{"path":"https://ninanor.github.io/eaTools/articles/normalise-condition-variable.html","id":"export-values","dir":"Articles","previous_headings":"Plotting the results","what":"Export values","title":"Normalise condition variable","text":"’ve found correct settings normalisation, can export new values like .","code":"ex_polygons$condition_indicator_2 <- eaTools::ea_normalise(data = ex_polygons,              vector = \"condition_variable_2\",              upper_reference_level = 7)"},{"path":"https://ninanor.github.io/eaTools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Anders Kolstad. Author, maintainer.","code":""},{"path":"https://ninanor.github.io/eaTools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kolstad (2023). eaTools: Tools Ecosystem Accounting. R package version 0.0.0.9000, https://ninanor.github.io/eaTools/.","code":"@Manual{,   title = {eaTools: Tools for Ecosystem Accounting},   author = {Anders Kolstad},   year = {2023},   note = {R package version 0.0.0.9000},   url = {https://ninanor.github.io/eaTools/}, }"},{"path":"https://ninanor.github.io/eaTools/index.html","id":"eatools-","dir":"","previous_headings":"","what":"Tools for Ecosystem Accounting","title":"Tools for Ecosystem Accounting","text":"goal eaTools provide tools creating ecosystem accounts.","code":""},{"path":"https://ninanor.github.io/eaTools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Ecosystem Accounting","text":"can install development version eaTools GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"NINAnor/eaTools\")"},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":null,"dir":"Reference","previous_headings":"","what":"accounting_area — accounting_area","title":"accounting_area — accounting_area","text":"accounting_area outline five regions.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"accounting_area — accounting_area","text":"","code":"accounting_area"},{"path":"https://ninanor.github.io/eaTools/reference/accounting_area.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"accounting_area — accounting_area","text":"sf object name Municipality name SHAPE_Area area polygons geometry geometry sf object","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_homogeneous_area — ea_homogeneous_area","title":"ea_homogeneous_area — ea_homogeneous_area","text":"function create new geometry based two input geometries. function meant precede ea_spread define homogeneous area can spread (.e. aggregate) indicator values.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_homogeneous_area — ea_homogeneous_area","text":"","code":"ea_homogeneous_area(   delineation1,   delineation2,   outline,   keep1 = NULL,   keep2 = NULL,   groups )"},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_homogeneous_area — ea_homogeneous_area","text":"delineation1 geometry (sf stars object) delineation2 second, optional, sf object, crs delineation1. outline optional sf object mask areas outside . keep1 Column names delineation1 keep returned object. delineation1 sf object. keep2 Column names delineation2 keep returned object. groups delineation1 stars object, select attribute designates homogeneous areas class.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_homogeneous_area — ea_homogeneous_area","text":"function returns sf object polygons defined intersection delineation1, delineation2 outline. Delineation1 can raster (stars object), vectorised, neighboring cells identical values merged. Delineation1 delineation2 normally completely overlapping, since areas covered layers dropped output. optional outline layer can used cut away areas, typically areas outside accounting area.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_homogeneous_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_homogeneous_area — ea_homogeneous_area","text":"","code":"data(\"ex_raster\") data(\"ex_polygons\") data(\"accounting_area\") # Example 1: two sf objects ex1 <- ea_homogeneous_area(ex_polygons,           accounting_area,           keep1 = \"condition_variable_2\",           keep2 = \"name\") #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Warning: repeating attributes for all sub-geometries for which they may not be constant # Only the names given by `keep1` and `keep2` are retained: names(ex1) #> [1] \"name\"                 \"condition_variable_2\" \"geometry\"             # Example 2: One stars object and one sf object ex2 <- ea_homogeneous_area(ex_raster,           accounting_area,           keep2 = \"name\",           groups = values) #> Warning: repeating attributes for all sub-geometries for which they may not be constant #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Warning: repeating attributes for all sub-geometries for which they may not be constant tmap::tm_shape(ex2)+  tmap::tm_polygons(col = \"values\")+ tmap::tm_shape(ex2[ex2$name == \"Enebakk\",])+    tmap::tm_polygons(col = \"blue\", border.col = \"black\")  # Example 3: Example 2 + outline enebakk <- accounting_area[accounting_area$name == \"Enebakk\",] ex3 <- ea_homogeneous_area(ex_raster,           accounting_area,           enebakk,           keep2 = \"name\",           groups = values) #> Warning: repeating attributes for all sub-geometries for which they may not be constant #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Warning: repeating attributes for all sub-geometries for which they may not be constant #> Warning: attribute variables are assumed to be spatially constant throughout all geometries tmap::tm_shape(ex3)+           tmap::tm_polygons(col = \"values\")"},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_normalise — ea_normalise","title":"ea_normalise — ea_normalise","text":"function normalise, re-scale, numerical vector condition variable become value 0 1, bound upper reference level.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_normalise — ea_normalise","text":"","code":"ea_normalise(   data = NULL,   vector = NULL,   upper_reference_level = NULL,   lower_reference_level = 0,   scaling_function = \"linear\",   reverse = FALSE,   break_point = NULL,   optimum = NULL,   plot = FALSE )"},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_normalise — ea_normalise","text":"data Data set class sf vector Numerical vector inside data normalised upper_reference_level upper reference level normalise vector. Can single number vector length equal vector. lower_reference_level lower reference level normalise vector. Defaults 0. Can single number vector length equal vector. scaling_function one c(\"linear\", \"sigmoid\", \"exponential convex\", \"exponential concave\") reverse Logical. indicator values reversed (.e. giving high variable value low indicator value) break_point Numerical vector single value indicating value variable scaled 0.6 indicator. optimum Numerical vector single value indicating upper reference value two-sided indicator. plot Logical. Wheter return plot comparing normalised raw values, return normalised values (default).","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_normalise — ea_normalise","text":"plot = TRUE return ggplot comparing normalised raw values. plot = False return numerical vector, normalised version vetcor","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_normalise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_normalise — ea_normalise","text":"","code":"data(\"ex_polygons\") ea_normalise(data = ex_polygons,             vector = \"condition_variable_2\",             upper_reference_level = 8,             plot=TRUE)"},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":null,"dir":"Reference","previous_headings":"","what":"ea_spread — ea_spread","title":"ea_spread — ea_spread","text":"function aggregate (area weigted means) indicator values stored spatial object (sf stars object) homogeneous area class, subsequently spread values populate area homogeneous area classes.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ea_spread — ea_spread","text":"","code":"ea_spread(   indicator_data,   indicator,   regions,   groups,   threshold = 1,   summarise = FALSE )"},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ea_spread — ea_spread","text":"indicator_data spatial object (currently inlo sf objects supported) containing scaled indicator values indicator Column name indicator_data containing indicator values. unquoted. regions sf object polygon values (slect colum using groups argument) assign areas homogeneous area classes. raster, use ea_homogeneous_areas() convert sf. groups Name regions containing homogeneous area classes. unquoted. threshold Number data points (.e. unique indicator values) needed calculate average indicator value. Defaults 1 (.e. threshold). summarise Logical. function return sf object wall--wall mean indicator values (default, summarise = FALSE), function return data frame summary statistics","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ea_spread — ea_spread","text":"case tally = FALSE, returned object sf object containing homogeneous area classes wall--wall mean indicator values. tally = TRUE, data frame summary statistics returned. Indicator values areas weighted (w_mean). summarise = TRUE, unweighted mean also returned (mean), along number data points (n), total area indicator data, standard deviation. SD returned cases, produced non-parametric bootstrapping 1000 replications.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ea_spread.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ea_spread — ea_spread","text":"","code":"data(\"ex_polygons\") data(\"ex_raster\")  # Example using a raster to define homogeneous area classes. # Zooming in on the example data ex_raster_zoom <- ex_raster[,5:6, 28:29] ex_polygons_zoom <- sf::st_crop(ex_polygons, ex_raster_zoom) #> Warning: attribute variables are assumed to be spatially constant throughout all geometries # Scale the indicator ex_polygons_zoom$indicator <- ea_normalise(ex_polygons_zoom, \"condition_variable_2\", upper_reference_level = 7) # Tweak the data slightly for exaggerated effect ex_polygons_zoom$indicator[2:6] <- 1 # Process the `ex_raster_zoom` and define homogeneous areas based on the cell values. myRegions <- ea_homogeneous_area(ex_raster_zoom, groups = values) # Now use the function out <- ea_spread(indicator_data = ex_polygons_zoom, indicator = indicator, regions = myRegions, groups = values) # And plot the results plot(out[,2])  #  Example 2: Summary output ea_spread(indicator_data = ex_polygons_zoom,   indicator = indicator,   regions = myRegions,   groups = values,   summarise = TRUE) #>   values total_area  n     w_mean      mean         sd #> 1      1  69675.832 30 0.24102147 0.3708932 0.07024698 #> 2      2  58330.105  7 0.08642357 0.3810810 0.12185424 #> 3      3   3351.623  3 0.65946526 0.7039941 0.21252193"},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":null,"dir":"Reference","previous_headings":"","what":"ex_polygons — ex_polygons","title":"ex_polygons — ex_polygons","text":"Example polygon data eaTools. ex_polygons sf object dummy condition variable (un-scaled). cover entire accounting area.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ex_polygons — ex_polygons","text":"","code":"ex_polygons"},{"path":"https://ninanor.github.io/eaTools/reference/ex_polygons.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"ex_polygons — ex_polygons","text":"sf object ID Unique row IDs SHAPE_Area area polygons SHAPE geometry sf object condition_variable_1 positive number zero 10 condition_variable_2 normally distributed vector mean =2 sd = 2 condition_variable_3 number value 0 1","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"ex_raster — ex_raster","title":"ex_raster — ex_raster","text":"ex_raster 1000x1000m raster grid extent account area, cells randomly classed either 1, 2 3.","code":""},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ex_raster — ex_raster","text":"","code":"ex_raster"},{"path":"https://ninanor.github.io/eaTools/reference/ex_raster.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"ex_raster — ex_raster","text":"stars object 40 rows 34 column(s)","code":""}]
